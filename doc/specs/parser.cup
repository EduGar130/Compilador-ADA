package compiler.syntax;


import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.semantic.SemanticErrors;
import compiler.semantic.type.TypeBoolean;
import compiler.semantic.type.TypeInteger;
import compiler.intermediate.*;
import compiler.code.*;

/* -----------------------------------------------------------------------------
 * parser.cup
 *
 * Gramática del compilador AdaUNED - Procesadores del Lenguaje II (PLII)
 *
 * Autor de la implementación: Eduardo Garcia Romera
 * Email: egarcia3266@alumno.uned.es
 * DNI: 54487155V
 * Versión: 1.0
 * 
 * Basado en la plantilla proporcionada por el Equipo Docente de PLII (Curso 2024-2025)
 * 
 * Esta implementación respeta la estructura base proporcionada y añade la propagación
 * de atributos para la construcción del árbol de derivación y su enriquecimiento semántico.
 * -----------------------------------------------------------------------------
 */
action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

	//Método para la creación de errores semánticos
	public void semanticFatalError(String errorMessage, int line, int column) {
        SemanticError sError = new SemanticError(errorMessage);
        sError.setLine(line);
        sError.setColumn(column);
        semanticErrorManager.semanticFatalError(sError);
    }
:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// TERMINALES

terminal Token MULT;
terminal Token MINUS;
terminal Token MAYOR;
terminal Token DISTINTO;
terminal Token ASIGNACION;
terminal Token ACCESO;
terminal Token PARENTESISAP;
terminal Token PARENTESISCIERRE;
terminal Token DELIMCOMENTARIO;
terminal Token DELIMCADENA;
terminal Token DELIMLISTA;
terminal Token DELIMPUNTOCOMA;
terminal Token DELIMTIPO;
terminal Token ENTERO;
terminal Token BOOLEANO;
terminal Token CADENACARACTERES;
terminal Token IDENTIFICADOR;
terminal Token CONSTANT;
terminal Token AND;
terminal Token PUTLINE;
terminal Token WHILE;
terminal Token ELSE;
terminal Token RETURN;
terminal Token IF;
terminal Token PROCEDURE;
terminal Token RECORD;
terminal Token FUNCTION;
terminal Token IS;
terminal Token THEN;
terminal Token INTEGER;
terminal Token BOOLEAN;
terminal Token END;
terminal Token BEGIN;
terminal Token LOOP;
terminal Token OUT;
terminal Token TYPE;
terminal Token IDERR;




// NO TERMINALES

non terminal Program                      	program;
non terminal Axiom                       	axiom;
non terminal Declaraciones                	declaraciones;
non terminal Cuerpo                       	cuerpo;
non terminal DeclConstantes             	declConstantes;
non terminal GrupoDeclaraciones1        	grupoDeclaraciones1;
non terminal DeclTipos                  	declTipos;
non terminal GrupoDeclaraciones2        	grupoDeclaraciones2;
non terminal DeclVariables              	declVariables;
non terminal GrupoDeclaraciones3        	grupoDeclaraciones3;
non terminal DeclSubprogramas          		declSubprogramas;
non terminal Constante                  	constante;
non terminal Literal                    	literal;
non terminal DeclTipo                   	declTipo;
non terminal DeclCampos                 	declCampos;
non terminal DeclCampo                  	declCampo;
non terminal Tipo                       	tipo;
non terminal DeclVariable               	declVariable;
non terminal DeclSubprograma            	declSubprograma;
non terminal DeclFunction               	declFunction;
non terminal DeclProcedimiento          	declProcedimiento;
non terminal DeclParametros             	declParametros;
non terminal TipoRetorno                	tipoRetorno;
non terminal DeclaracionesFunction      	declaracionesFunction;
non terminal CuerpoFunction             	cuerpoFunction;
non terminal DeclParametro              	declParametro;
non terminal ListaParametros            	listaParametros;
non terminal Sentencias                 	sentencias;
non terminal Sentencia                  	sentencia;
non terminal SentenciaPutLine           	sentenciaPutLine;
non terminal SentenciaAsignacion        	sentenciaAsignacion;
non terminal SentenciaIf                	sentenciaIf;
non terminal SentenciaWhile             	sentenciaWhile;
non terminal SentenciaReturn            	sentenciaReturn;
non terminal SentenciaProcedimiento     	sentenciaProcedimiento;
non terminal Ref                        	ref;
non terminal Expresion                  	expresion;
non terminal ExpresionAccesoRegistro    	expresionAccesoRegistro;
non terminal Parametro                  	parametro;
non terminal ExprFuncion                	exprFuncion;
non terminal OperadorLogico             	operadorLogico;
non terminal OperadorRelacional         	operadorRelacional;
non terminal OperadorAritmetico         	operadorAritmetico;
non terminal Operando                   	operando;
non terminal ListaParametrosInvocacion  	listaParametrosInvocacion;



// RELACIONES DE PRECEDENCIA Y ASOCIATIVIDADexpr.setType(((ExprFuncion)ef).getType());

precedence left     AND;
precedence left     DISTINTO;
precedence left     MAYOR;
precedence left     MINUS;
precedence left     MULT;
precedence left     IDENTIFICADOR, ACCESO, PARENTESISAP, PARENTESISCIERRE;



// REGLAS DE PRODUCCIÓN


start with program;

program ::=
  {: 
        syntaxErrorManager.syntaxInfo("Starting parsing...");

        // Apertura del Scope Global
        semanticErrorManager.semanticInfo("Abriendo Scope Global...");
        scopeManager.openScope("global");
        ScopeIF globalScope = scopeManager.getCurrentScope();
        semanticErrorManager.semanticDebug("Scope abierto: " + globalScope);

        // Registrar los tipos primitivos
        semanticErrorManager.semanticInfo("Registrando tipos primitivos...");
        TypeTableIF typeTable = globalScope.getTypeTable();

        TypeBoolean typeBoolean = new TypeBoolean(globalScope);
        typeTable.addType(typeBoolean);
        semanticErrorManager.semanticDebug("Tipo BOOLEAN registrado: " + typeBoolean);

        TypeInteger typeInteger = new TypeInteger(globalScope);
        typeTable.addType(typeInteger);
        semanticErrorManager.semanticDebug("Tipo INTEGER registrado: " + typeInteger);

        semanticErrorManager.semanticDebug("Tabla de tipos en scope global: " + typeTable);
  :}
  axiom:ax
  {:   		
        if (ax == null) {
            semanticFatalError(SemanticErrors.NPV, 0, 0);
        }

        semanticErrorManager.semanticInfo("Programa analizado correctamente.");
        semanticErrorManager.semanticDebug("AXIOM: " + ax.toString());

        List intermediateCode = ax.getIntermediateCode();
        if (intermediateCode != null) {
            semanticErrorManager.semanticInfo("Generamos output .ens");
            semanticErrorManager.semanticDebug("Código intermedio generado: " + intermediateCode);
            finalCodeFactory.create(intermediateCode);
        } else {
            semanticFatalError(SemanticErrors.NPV, 0, 0);
        }

        syntaxErrorManager.syntaxInfo("Parsing process ended.");
        scopeManager.closeScope();
        semanticErrorManager.semanticDebug("Scope Global cerrado correctamente.");
  :};

   

axiom ::= PROCEDURE IDENTIFICADOR:id PARENTESISAP PARENTESISCIERRE IS declaraciones:decl cuerpo:c
{:
    Token idToken = (Token) id;

    semanticErrorManager.semanticInfo("Procesando axioma del procedimiento: " + idToken.getLexema());

    if (decl == null) {
        semanticFatalError(SemanticErrors.NDC, idToken.getLine(), idToken.getColumn());
    }
    if (c == null) {
        semanticFatalError(SemanticErrors.CPI, idToken.getLine(), idToken.getColumn());
    }

    Axiom axiom = new Axiom(new Program(decl, c));

    // Añadimos el código intermedio
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (c.getIntermediateCode() != null) {
        intermediateCode.addAll(c.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, idToken.getLine(), idToken.getColumn());
    }
    if (decl.getIntermediateCode() != null) {
        intermediateCode.addAll(decl.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, idToken.getLine(), idToken.getColumn());
    }
    axiom.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Declaraciones procesadas: " + decl.toString());
    semanticErrorManager.semanticDebug("Cuerpo del programa: " + c.toString());
    semanticErrorManager.semanticDebug("Objeto Axiom generado: " + axiom.toString());

    RESULT = axiom;
:};

            

//declaraciones
declaraciones ::= declConstantes:dc grupoDeclaraciones1:gd1
{:
    semanticErrorManager.semanticInfo("Procesando conjunto de declaraciones con constantes y declaraciones generales.");

    Declaraciones declaraciones = new Declaraciones();
    declaraciones.setDeclConstantes((DeclConstantes) dc);
    declaraciones.setGrupoDeclaraciones1((GrupoDeclaraciones1) gd1);

    // Añadimos el código intermedio de las declaraciones
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (dc.getIntermediateCode() != null) {
        intermediateCode.addAll(dc.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    if (gd1.getIntermediateCode() != null) {
        intermediateCode.addAll(gd1.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    declaraciones.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("DeclConstantes: " + dc.toString());
    semanticErrorManager.semanticDebug("GrupoDeclaraciones1: " + gd1.toString());
    semanticErrorManager.semanticDebug("Declaraciones generadas: " + declaraciones.toString());

    RESULT = declaraciones;
:}
| grupoDeclaraciones1:gd1
{:
    semanticErrorManager.semanticInfo("Procesando conjunto de declaraciones sin constantes.");

    Declaraciones declaraciones = new Declaraciones();
    declaraciones.setGrupoDeclaraciones1((GrupoDeclaraciones1) gd1);

    // Añadimos el código intermedio del grupo de declaraciones
    if (gd1.getIntermediateCode() != null) {
        declaraciones.setIntermediateCode(gd1.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }

    semanticErrorManager.semanticDebug("GrupoDeclaraciones1: " + gd1.toString());
    semanticErrorManager.semanticDebug("Declaraciones generadas: " + declaraciones.toString());

    RESULT = declaraciones;
:};

grupoDeclaraciones1 ::= declTipos:dt grupoDeclaraciones2:gd2 // TODO
{:
    semanticErrorManager.semanticInfo("Procesando grupo de declaraciones 1 con tipos y grupo de declaraciones 2.");

    GrupoDeclaraciones1 grupoDeclaraciones1 = new GrupoDeclaraciones1();
    grupoDeclaraciones1.setDeclTipos((DeclTipos) dt);
    grupoDeclaraciones1.setGrupoDeclaraciones2((GrupoDeclaraciones2) gd2);

    // Añadimos el código intermedio de las declaraciones
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (dt.getIntermediateCode() != null) {
        intermediateCode.addAll(dt.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    if (gd2.getIntermediateCode() != null) {
        intermediateCode.addAll(gd2.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    grupoDeclaraciones1.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("DeclTipos: " + dt.toString());
    semanticErrorManager.semanticDebug("GrupoDeclaraciones2: " + gd2.toString());
    semanticErrorManager.semanticDebug("GrupoDeclaraciones1 generado: " + grupoDeclaraciones1.toString());

    RESULT = grupoDeclaraciones1;
:}
| grupoDeclaraciones2:gd2
{:
    semanticErrorManager.semanticInfo("Procesando grupo de declaraciones 1 sin tipos (solo grupo de declaraciones 2).");

    GrupoDeclaraciones1 grupoDeclaraciones1 = new GrupoDeclaraciones1();
    grupoDeclaraciones1.setGrupoDeclaraciones2((GrupoDeclaraciones2) gd2);

    // Añadimos el código intermedio del grupo de declaraciones 2
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (gd2.getIntermediateCode() != null) {
        grupoDeclaraciones1.setIntermediateCode(gd2.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    grupoDeclaraciones1.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("GrupoDeclaraciones2: " + gd2.toString());
    semanticErrorManager.semanticDebug("GrupoDeclaraciones1 generado: " + grupoDeclaraciones1.toString());

    RESULT = grupoDeclaraciones1;
:};

grupoDeclaraciones2 ::= declVariables:dv grupoDeclaraciones3:gd3
{:
    semanticErrorManager.semanticInfo("Procesando grupo de declaraciones 2 con variables y grupo de declaraciones 3.");

    GrupoDeclaraciones2 grupoDeclaraciones2 = new GrupoDeclaraciones2();
    grupoDeclaraciones2.setDeclVariables((DeclVariables) dv);
    grupoDeclaraciones2.setGrupoDeclaraciones3((GrupoDeclaraciones3) gd3);

    // Añadimos el código intermedio de las declaraciones
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (dv.getIntermediateCode() != null) {
        intermediateCode.addAll(dv.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    if (gd3.getIntermediateCode() != null) {
        intermediateCode.addAll(gd3.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    grupoDeclaraciones2.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("DeclVariables: " + dv.toString());
    semanticErrorManager.semanticDebug("GrupoDeclaraciones3: " + gd3.toString());
    semanticErrorManager.semanticDebug("GrupoDeclaraciones2 generado: " + grupoDeclaraciones2.toString());

    RESULT = grupoDeclaraciones2;
:}
| grupoDeclaraciones3:gd3
{:
    semanticErrorManager.semanticInfo("Procesando grupo de declaraciones 2 sin variables (solo grupo de declaraciones 3).");

    GrupoDeclaraciones2 grupoDeclaraciones2 = new GrupoDeclaraciones2();
    grupoDeclaraciones2.setGrupoDeclaraciones3((GrupoDeclaraciones3) gd3);

    // Añadimos el código intermedio de las declaraciones
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (gd3.getIntermediateCode() != null) {
        intermediateCode.addAll(gd3.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    grupoDeclaraciones2.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("GrupoDeclaraciones3: " + gd3.toString());
    semanticErrorManager.semanticDebug("GrupoDeclaraciones2 generado: " + grupoDeclaraciones2.toString());

    RESULT = grupoDeclaraciones2;
:};

grupoDeclaraciones3 ::= declSubprogramas:ds
{:
    semanticErrorManager.semanticInfo("Procesando grupo de declaraciones 3 con subprogramas.");

    GrupoDeclaraciones3 grupoDeclaraciones3 = new GrupoDeclaraciones3();
    grupoDeclaraciones3.setDeclSubprogramas((DeclSubprogramas) ds);

    // Añadimos el código intermedio de las declaraciones
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (ds.getIntermediateCode() != null) {
        intermediateCode.addAll(ds.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }

    semanticErrorManager.semanticDebug("DeclSubprogramas: " + ds.toString());
    semanticErrorManager.semanticDebug("GrupoDeclaraciones3 generado: " + grupoDeclaraciones3.toString());

    RESULT = grupoDeclaraciones3;
:}
| /* vacío */
{:
    semanticErrorManager.semanticInfo("Procesando grupo de declaraciones 3 vacío (sin subprogramas).");

    GrupoDeclaraciones3 grupoDeclaraciones3 = new GrupoDeclaraciones3();
    grupoDeclaraciones3.setDeclSubprogramas(null);

    // No hay código intermedio que añadir, ya que no hay subprogramas

    semanticErrorManager.semanticDebug("GrupoDeclaraciones3 generado (vacío): " + grupoDeclaraciones3.toString());

    RESULT = grupoDeclaraciones3;
:};

//declaración de constantes
declConstantes ::= constante:c
{:
    semanticErrorManager.semanticInfo("Procesando primera constante simbólica.");

    DeclConstantes declConstantes = new DeclConstantes();
    declConstantes.addConstante(c);

    // Añadimos el código intermedio de la constante
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (c.getIntermediateCode() != null) {
        intermediateCode.addAll(c.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }

    declConstantes.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Constante añadida: " + c.toString());
    semanticErrorManager.semanticDebug("DeclConstantes actual: " + declConstantes.toString());

    RESULT = declConstantes;
:}
| declConstantes:dcs constante:c
{:
    semanticErrorManager.semanticInfo("Añadiendo constante simbólica adicional.");

    dcs.addConstante(c);

    // Añadimos también su código intermedio
    if (c.getIntermediateCode() != null) {
        dcs.getIntermediateCode().addAll(c.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }

    semanticErrorManager.semanticDebug("Constante añadida: " + c.toString());
    semanticErrorManager.semanticDebug("DeclConstantes actualizada: " + dcs.toString());

    RESULT = dcs;
:};

constante ::= IDENTIFICADOR:id DELIMTIPO CONSTANT ASIGNACION literal:lit DELIMPUNTOCOMA
{:
    semanticErrorManager.semanticInfo("Procesando declaración de constante simbólica: " + id.getLexema());

    TypeIF type = ((Literal) lit).getType();
    SymbolConstant symbol = new SymbolConstant(id.getLexema(), scopeManager.getCurrentScope(), type);
    symbol.setValue(((Literal) lit).getValor());
    symbol.setType(type);

    SymbolTableIF symbolTable = scopeManager.getCurrentScope().getSymbolTable();

    if (symbolTable.containsSymbol(id.getLexema())) {
        semanticFatalError("Constante duplicada: " + id.getLexema(), id.getLine(), id.getColumn());
    }

    symbolTable.addSymbol(symbol);

    semanticErrorManager.semanticDebug("Constante añadida -> " + symbol.toString());
    semanticErrorManager.semanticDebug("Tabla de símbolos actualizada:\n" + symbolTable.toString());

    Constante constante = new Constante(symbol, type);
    semanticErrorManager.semanticDebug("Objeto Constante generado: " + constante.toString());

    // Generación del código intermedio
    List<QuadrupleIF> intermediateCode = new ArrayList<>();

    if (lit.getIntermediateCode() != null) {
        intermediateCode.addAll(lit.getIntermediateCode());

        // Añadir el cuarteto MOVE para asociar el valor del literal al identificador de la constante
        Variable constantRef = new Variable(id.getLexema(), scopeManager.getCurrentScope());
        intermediateCode.add(new Quadruple(Nemonic.MOVE, constantRef, ((Literal) lit).getTemporal(), null));
    } else {
        semanticFatalError(SemanticErrors.NPV, id.getLine(), id.getColumn());
    }

    // Asociamos el código intermedio a la constante
    constante.setIntermediateCode(intermediateCode);
    semanticErrorManager.semanticDebug("Código intermedio generado para la constante: " + constante.getIntermediateCode());

    RESULT = constante;
:};

literal ::= ENTERO:ent
{:
    semanticErrorManager.semanticInfo("Procesando literal entero: " + ent.getLexema());

    // Tipo entero
    TypeInteger typeInteger = (TypeInteger) scopeManager.searchType("INTEGER");
    Literal literal = new Literal(ent.getLexema(), typeInteger);

    // Creamos el temporal
    if (scopeManager.getCurrentScope() != null) {
        literal.crearTemporal(scopeManager.getCurrentScope());
        semanticErrorManager.semanticDebug("Literal entero con temporal generado: " + literal.toString());
    } else {
        semanticErrorManager.semanticFatalError("[Error] Scope actual no disponible para crear temporal.");
    }

    // Código intermedio: asignamos el literal a su temporal
    IntermediateCodeBuilder builder = new IntermediateCodeBuilder(scopeManager.getCurrentScope());

    Value value = new Value(Integer.parseInt(ent.getLexema()));
    builder.addQuadruple(Nemonic.MOVE, literal.getTemporal(), value, null);

    // Asociamos el código intermedio al literal
    literal.setIntermediateCode(builder.create());

    RESULT = literal;
:}
| BOOLEANO:bool
{:
    semanticErrorManager.semanticInfo("Procesando literal booleano: " + bool.getLexema());

    // Tipo booleano
    TypeBoolean typeBoolean = (TypeBoolean) scopeManager.searchType("BOOLEAN");
    Literal literal = new Literal(bool.getLexema(), typeBoolean);

    // Creamos el temporal
    if (scopeManager.getCurrentScope() != null) {
        literal.crearTemporal(scopeManager.getCurrentScope());
        semanticErrorManager.semanticDebug("Literal booleano con temporal generado: " + literal.toString());
    } else {
        semanticErrorManager.semanticFatalError("[Error] Scope actual no disponible para crear temporal.");
    }

    // Código intermedio: asignamos el valor booleano al temporal
    IntermediateCodeBuilder builder = new IntermediateCodeBuilder(scopeManager.getCurrentScope());

    Value value = new Value(bool.getLexema()); // "True" o "False"
    builder.addQuadruple(Nemonic.MOVE, literal.getTemporal(), value, null);

    // Asociamos el código intermedio al literal
    literal.setIntermediateCode(builder.create());

    RESULT = literal;
:};

//declaración de tipos estructurados
declTipos ::= declTipo:dt
{:
    semanticErrorManager.semanticInfo("Procesando primer tipo definido por el usuario.");

    DeclTipos declTipos = new DeclTipos();
    declTipos.addTipo(dt);

    // Añadimos el código intermedio del tipo
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (dt.getIntermediateCode() != null) {
        intermediateCode.addAll(dt.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    declTipos.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Tipo añadido: " + dt.toString());
    semanticErrorManager.semanticDebug("DeclTipos generado: " + declTipos.toString());

    RESULT = declTipos;
:}
| declTipos:dts declTipo:dt
{:
    semanticErrorManager.semanticInfo("Procesando tipo adicional definido por el usuario.");

    dts.addTipo(dt);
    // Añadimos también su código intermedio
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (dt.getIntermediateCode() != null) {
        dts.getIntermediateCode().addAll(dt.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    dts.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Tipo añadido: " + dt.toString());
    semanticErrorManager.semanticDebug("DeclTipos actualizado: " + dts.toString());

    RESULT = dts;
:};

declTipo ::= TYPE IDENTIFICADOR:id IS RECORD declCampos:dcs END RECORD DELIMPUNTOCOMA
{:
    String nombreTipo = id.getLexema();
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeTableIF typeTable = scope.getTypeTable();

    semanticErrorManager.semanticInfo("Procesando declaración de tipo RECORD: " + nombreTipo);

    if (typeTable.containsType(nombreTipo)) {
        semanticFatalError("Tipo duplicado: " + nombreTipo, id.getLine(), id.getColumn());
    }

    TypeRecord typeRecord = new TypeRecord(scope, nombreTipo);

    List<DeclCampo> campos = ((DeclCampos) dcs).getCampos();

    if (campos == null || campos.isEmpty()) {
        semanticFatalError("El tipo record '" + nombreTipo + "' no puede tener campos vacíos.", id.getLine(), id.getColumn());
    }

    for (DeclCampo campo : campos) {
        typeRecord.addCampo(campo.getNombre(), campo.getTipo().getType());
        semanticErrorManager.semanticDebug("Campo añadido al tipo '" + nombreTipo + "': " +
            campo.getNombre() + " : " + campo.getTipo().getType().getName());
    }

    typeTable.addType(typeRecord);

    semanticErrorManager.semanticDebug("Tipo RECORD añadido a la tabla de tipos: " + typeRecord.toString());
    semanticErrorManager.semanticDebug("Tabla de tipos actualizada:\n" + typeTable.toString());

    RESULT = new DeclTipo(typeRecord);
:};

// declaración de campos
declCampos ::= declCampo:dc
{:
    semanticErrorManager.semanticInfo("Procesando primer campo de tipo RECORD.");

    DeclCampos declCampos = new DeclCampos();
    declCampos.addCampo((DeclCampo) dc);

    semanticErrorManager.semanticDebug("Campo añadido: " + dc.toString());
    semanticErrorManager.semanticDebug("DeclCampos generado: " + declCampos.toString());

    RESULT = declCampos;
:}
| declCampos:dcs declCampo:dc
{:
    semanticErrorManager.semanticInfo("Procesando campo adicional para tipo RECORD.");

    dcs.addCampo((DeclCampo) dc);

    semanticErrorManager.semanticDebug("Campo añadido: " + dc.toString());
    semanticErrorManager.semanticDebug("DeclCampos actualizado: " + dcs.toString());

    RESULT = dcs;
:};

declCampo ::= IDENTIFICADOR:id DELIMTIPO tipo:t DELIMPUNTOCOMA
{:
    semanticErrorManager.semanticInfo("Procesando declaración de campo: " + id.getLexema());

    DeclCampo declCampo = new DeclCampo();
    declCampo.setNombre(id.getLexema());
    declCampo.setTipo((Tipo) t);

    semanticErrorManager.semanticDebug("Campo creado: " + declCampo.toString());

    RESULT = declCampo;
:};

//declaración de variables globales
declVariables ::= declVariable:dv
{:
    semanticErrorManager.semanticInfo("Procesando primera variable global.");

    DeclVariables declVariables = new DeclVariables();
    declVariables.addVariable(dv);

    semanticErrorManager.semanticDebug("Variable añadida: " + dv.toString());
    semanticErrorManager.semanticDebug("DeclVariables generado: " + declVariables.toString());

    RESULT = declVariables;
:}
| declVariables:dvs declVariable:dv
{:
    semanticErrorManager.semanticInfo("Procesando variable global adicional.");

    dvs.addVariable(dv);

    semanticErrorManager.semanticDebug("Variable añadida: " + dv.toString());
    semanticErrorManager.semanticDebug("DeclVariables actualizado: " + dvs.toString());

    RESULT = dvs;
:};

declVariable ::= IDENTIFICADOR:id DELIMTIPO tipo:t DELIMPUNTOCOMA
{:
    String nombre = id.getLexema();
    TypeIF tipoVariable = ((Tipo)t).getType();

    semanticErrorManager.semanticInfo("Procesando declaración de variable: " + nombre + " : " + tipoVariable.getName());

    SymbolVariable symbol = new SymbolVariable(scopeManager.getCurrentScope(), nombre, tipoVariable);

    SymbolTableIF symbolTable = scopeManager.getCurrentScope().getSymbolTable();
    if (symbolTable.containsSymbol(nombre)) {
        semanticFatalError("Variable duplicada: " + nombre, id.getLine(), id.getColumn());
    }
    symbolTable.addSymbol(symbol);

    // Código intermedio: declarar variable
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
    Variable var = new Variable(nombre, symbol.getScope());
    iCb.addQuadruple(Nemonic.DECL, var);

    DeclVariable declVariable = new DeclVariable(nombre, tipoVariable);
    declVariable.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Variable registrada en TS: " + symbol.toString());
    semanticErrorManager.semanticDebug("Tabla de símbolos tras inserción:\n" + symbolTable.toString());

    RESULT = declVariable;
:}
| IDENTIFICADOR:id DELIMLISTA declVariable:dv
{:
    String nombre = id.getLexema();
    TypeIF tipoVariable = ((DeclVariable)dv).getTipo();

    semanticErrorManager.semanticInfo("Procesando variable en lista: " + nombre + " : " + tipoVariable.getName());

    SymbolVariable symbol = new SymbolVariable(scopeManager.getCurrentScope(), nombre, tipoVariable);

    SymbolTableIF symbolTable = scopeManager.getCurrentScope().getSymbolTable();
    if (symbolTable.containsSymbol(nombre)) {
        semanticFatalError("Variable duplicada: " + nombre, id.getLine(), id.getColumn());
    }
    symbolTable.addSymbol(symbol);

    // Código intermedio: declarar variable
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
    Variable var = new Variable(nombre, symbol.getScope());
    iCb.addQuadruple(Nemonic.DECL, var);

    DeclVariable declVariable = new DeclVariable(nombre, tipoVariable);
    List<QuadrupleIF> code = new ArrayList<>(dv.getIntermediateCode());
    code.addAll(iCb.create());
    declVariable.setIntermediateCode(code);

    semanticErrorManager.semanticDebug("Variable registrada en TS: " + symbol.toString());
    semanticErrorManager.semanticDebug("Tabla de símbolos tras inserción:\n" + symbolTable.toString());

    RESULT = declVariable;
:};

tipo ::= INTEGER
{:
    semanticErrorManager.semanticInfo("Procesando tipo primitivo INTEGER.");
    
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeInteger typeInteger = (TypeInteger) scopeManager.searchType("INTEGER");

    if (typeInteger == null) {
        semanticFatalError("Tipo INTEGER no encontrado en la tabla de tipos.", 0, 0);
    }

    Tipo tipo = new Tipo();
    tipo.setType(typeInteger);

    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
    iCb.addQuadruple(Nemonic.TYPE_USED, "INTEGER"); // Cuarteto simbólico, solo trazabilidad

    tipo.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Tipo construido: " + tipo.toString());

    RESULT = tipo;
:}
| BOOLEAN
{:
    semanticErrorManager.semanticInfo("Procesando tipo primitivo BOOLEAN.");
    
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeBoolean typeBoolean = (TypeBoolean) scopeManager.searchType("BOOLEAN");

    if (typeBoolean == null) {
        semanticFatalError("Tipo BOOLEAN no encontrado en la tabla de tipos.", 0, 0);
    }

    Tipo tipo = new Tipo();
    tipo.setType(typeBoolean);

    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
    iCb.addQuadruple(Nemonic.TYPE_USED, "BOOLEAN"); // Cuarteto simbólico

    tipo.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Tipo construido: " + tipo.toString());

    RESULT = tipo;
:}
| IDENTIFICADOR:id
{:
    String nombreTipo = id.getLexema();
    semanticErrorManager.semanticInfo("Procesando tipo definido por el usuario: " + nombreTipo);
    
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeIF tipoUsuario = scope.getTypeTable().getType(nombreTipo);

    if (tipoUsuario == null) {
        semanticFatalError("Tipo '" + nombreTipo + "' no declarado en el ámbito actual.", id.getLine(), id.getColumn());
    }

    Tipo tipo = new Tipo();
    tipo.setType(tipoUsuario);

    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
    iCb.addQuadruple(Nemonic.TYPE_USED, nombreTipo); // Trazabilidad útil para RECORDs

    tipo.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Tipo usuario vinculado: " + tipoUsuario.getName());
    semanticErrorManager.semanticDebug("Tipo construido: " + tipo.toString());

    RESULT = tipo;
:};

//declaración subprograma
declSubprogramas ::= declSubprograma:ds
{:
    semanticErrorManager.semanticInfo("Procesando primer subprograma.");

    DeclSubprogramas declSubprogramas = new DeclSubprogramas();
    declSubprogramas.addSubprograma((DeclSubprograma) ds);

    // Añadimos el código intermedio del subprograma
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (ds.getIntermediateCode() != null) {
        intermediateCode.addAll(ds.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    declSubprogramas.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Subprograma añadido: " + ds.toString());
    semanticErrorManager.semanticDebug("DeclSubprogramas generado: " + declSubprogramas.toString());

    RESULT = declSubprogramas;
:}
| declSubprogramas:dss declSubprograma:ds
{:
    semanticErrorManager.semanticInfo("Procesando subprograma adicional.");

    dss.addSubprograma((DeclSubprograma) ds);

    // Añadimos también su código intermedio
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (dss.getIntermediateCode() != null) {
        intermediateCode.addAll(dss.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    if (ds.getIntermediateCode() != null) {
        intermediateCode.addAll(ds.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    dss.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Subprograma añadido: " + ds.toString());
    semanticErrorManager.semanticDebug("DeclSubprogramas actualizado: " + dss.toString());

    RESULT = dss;
:};

declSubprograma ::= declFunction:df
{:
    semanticErrorManager.semanticInfo("Procesando subprograma tipo FUNCIÓN.");

    DeclSubprograma declSubprograma = new DeclSubprograma();
    declSubprograma.setFunction((DeclFunction) df);

    // Añadimos el código intermedio de la función
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (df.getIntermediateCode() != null) {
        intermediateCode.addAll(df.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    declSubprograma.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Función añadida al DeclSubprograma: " + df.toString());

    RESULT = declSubprograma;
:}
| declProcedimiento:dp
{:
    semanticErrorManager.semanticInfo("Procesando subprograma tipo PROCEDIMIENTO.");

    DeclSubprograma declSubprograma = new DeclSubprograma();
    declSubprograma.setProcedimiento((DeclProcedimiento) dp);

    // Añadimos el código intermedio del procedimiento
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (dp.getIntermediateCode() != null) {
        intermediateCode.addAll(dp.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    declSubprograma.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Procedimiento añadido al DeclSubprograma: " + dp.toString());

    RESULT = declSubprograma;
:};

//declaración función
declFunction ::= FUNCTION IDENTIFICADOR:id PARENTESISAP declParametros:dp PARENTESISCIERRE RETURN tipoRetorno:tr IS
{:
    semanticErrorManager.semanticInfo("Procesando declaración de función con parámetros: " + id.getLexema());
    // Abrir un nuevo ámbito para la función
    ScopeIF subprogramScope = scopeManager.openScope(id.getLexema());
    SymbolTableIF symbolTable = subprogramScope.getSymbolTable();
    if (symbolTable.containsSymbol(id.getLexema())) {
        semanticFatalError("Función duplicada: " + id.getLexema(), id.getLine(), id.getColumn());
    }
    semanticErrorManager.semanticDebug("Ámbito de la función abierto: " + subprogramScope.getName());
    // Registrar los parámetros en el ámbito de la función
    for (DeclParametro parametro : ((DeclParametros) dp).getParametros()) {
        List<String> nombresParametros = parametro.getListaParametros().getIdentificadores();
        for(String paramName : nombresParametros) {
            TypeIF paramType = parametro.getTipo().getType();
            SymbolVariable symbol = new SymbolVariable(subprogramScope, paramName, paramType);
            if (symbolTable.containsSymbol(paramName)) {
                semanticFatalError("Parámetro duplicado: " + paramName, id.getLine(), id.getColumn());
            }
            symbolTable.addSymbol(symbol);
            semanticErrorManager.semanticDebug("Parámetro añadido al ámbito de la función: " + symbol.toString());
        }
    }
    semanticErrorManager.semanticDebug("Tabla de símbolos en el ámbito de la función: " + symbolTable.toString());
:}
declaracionesFunction:df cuerpoFunction:cf
{:
    // Crear el objeto DeclFunction
    DeclFunction declFunction = new DeclFunction();
    declFunction.setNombre(id.getLexema());
    declFunction.setParametros((DeclParametros) dp);
    declFunction.setTipoRetorno((TipoRetorno) tr);
    declFunction.setDeclaraciones((DeclaracionesFunction) df);
    declFunction.setCuerpo((CuerpoFunction) cf);

    semanticErrorManager.semanticDebug("Función declarada: " + declFunction.toString());
    ScopeIF subprogramScope = scopeManager.getCurrentScope();

    // Obtenemos los parametros de la función
    List<SymbolParameter> parametros = new ArrayList<>();
    for (DeclParametro parametro : ((DeclParametros) dp).getParametros()) {
        List<String> nombresParametros = parametro.getListaParametros().getIdentificadores();
        TypeIF tipoParametro = parametro.getTipo().getType();
        for (String paramName : nombresParametros) {
            SymbolParameter symbolParameter = new SymbolParameter(subprogramScope, paramName, tipoParametro);
            parametros.add(symbolParameter);
            semanticErrorManager.semanticDebug("Parámetro añadido: " + symbolParameter.toString());
        }
    }

    //Cerrar el ámbito de la función
    scopeManager.closeScope();
    semanticErrorManager.semanticDebug("Ámbito de la función cerrado correctamente.");

    // Añadir la función a la tabla de símbolos del ámbito superior
    ScopeIF fatherScope = scopeManager.getCurrentScope();
    SymbolTableIF fatherSymbolTable = fatherScope.getSymbolTable();
    if (fatherSymbolTable.containsSymbol(id.getLexema())) {
        semanticFatalError("Función duplicada: " + id.getLexema(), id.getLine(), id.getColumn());
    }
    fatherSymbolTable.addSymbol(new SymbolFunction(fatherScope, declFunction.getNombre(), declFunction.getTipoRetorno().getType(), parametros));

    semanticErrorManager.semanticDebug("Función añadida a la tabla de símbolos del ámbito padre: " + declFunction.getNombre());

    RESULT = declFunction;
:}
| FUNCTION IDENTIFICADOR:id PARENTESISAP PARENTESISCIERRE RETURN tipoRetorno:tr IS declaracionesFunction:df cuerpoFunction:cf
{:
    semanticErrorManager.semanticInfo("Procesando declaración de función sin parámetros: " + id.getLexema());

    // Abrir un nuevo ámbito para la función
    ScopeIF subprogramScope = scopeManager.openScope(id.getLexema());
    SymbolTableIF symbolTable = subprogramScope.getSymbolTable();

    DeclFunction declFunction = new DeclFunction();
    declFunction.setNombre(id.getLexema());
    declFunction.setParametros(null);
    declFunction.setTipoRetorno((TipoRetorno) tr);
    declFunction.setDeclaraciones((DeclaracionesFunction) df);
    declFunction.setCuerpo((CuerpoFunction) cf);

    semanticErrorManager.semanticDebug("Función declarada: " + declFunction.toString());

    //Cerrar el ámbito de la función
    scopeManager.closeScope();
    semanticErrorManager.semanticDebug("Ámbito de la función cerrado correctamente.");
    RESULT = declFunction;
:};
				
declParametros ::= declParametro:dp DELIMPUNTOCOMA declParametros:dps
{:
    semanticErrorManager.semanticInfo("Procesando parámetro seguido de más parámetros.");
    ScopeIF scope = scopeManager.getCurrentScope();
    DeclParametros declParametros = new DeclParametros();
    declParametros.addParametro((DeclParametro) dp);
    declParametros.getParametros().addAll(((DeclParametros) dps).getParametros());

    semanticErrorManager.semanticDebug("Parámetro añadido: " + dp.toString());
    semanticErrorManager.semanticDebug("DeclParametros actualizado: " + declParametros.toString());

    RESULT = declParametros;
:}
| declParametro:dp
{:
    semanticErrorManager.semanticInfo("Procesando único parámetro.");

    DeclParametros declParametros = new DeclParametros();
    declParametros.addParametro((DeclParametro) dp);

    semanticErrorManager.semanticDebug("Parámetro añadido: " + dp.toString());
    semanticErrorManager.semanticDebug("DeclParametros generado: " + declParametros.toString());

    RESULT = declParametros;
:};

declParametro ::= listaParametros:lp DELIMTIPO tipo:t
{:
    semanticErrorManager.semanticInfo("Procesando parámetro(s) tipo IN.");

    DeclParametro declParametro = new DeclParametro();
    declParametro.setListaParametros((ListaParametros) lp);
    declParametro.setTipo((Tipo) t);
    declParametro.setSalida(false);

    semanticErrorManager.semanticDebug("Parámetro IN: " + declParametro.toString());

    RESULT = declParametro;
:}
| listaParametros:lp DELIMTIPO OUT tipo:t
{:
    semanticErrorManager.semanticInfo("Procesando parámetro(s) tipo OUT.");

    DeclParametro declParametro = new DeclParametro();
    declParametro.setListaParametros((ListaParametros) lp);
    declParametro.setTipo((Tipo) t);
    declParametro.setSalida(true);

    semanticErrorManager.semanticDebug("Parámetro OUT: " + declParametro.toString());

    RESULT = declParametro;
:};
	
listaParametros ::= IDENTIFICADOR:id DELIMLISTA listaParametros:lps
{:
    semanticErrorManager.semanticInfo("Añadiendo identificador a lista de parámetros: " + id.getLexema());

    ListaParametros listaParametros = (ListaParametros) lps;
    listaParametros.addIdentificador(id.getLexema());

    semanticErrorManager.semanticDebug("ListaParametros actualizada: " + listaParametros.toString());

    RESULT = listaParametros;
:}
| IDENTIFICADOR:id
{:
    semanticErrorManager.semanticInfo("Creando nueva lista de parámetros con: " + id.getLexema());

    ListaParametros listaParametros = new ListaParametros();
    listaParametros.addIdentificador(id.getLexema());

    semanticErrorManager.semanticDebug("ListaParametros creada: " + listaParametros.toString());

    RESULT = listaParametros;
:};

tipoRetorno ::= INTEGER
{:
    semanticErrorManager.semanticInfo("Procesando tipo de retorno INTEGER.");
    
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeInteger typeInteger = (TypeInteger) scopeManager.searchType("INTEGER");

    if (typeInteger == null) {
        semanticFatalError("Tipo INTEGER no encontrado en tabla de tipos.", 0, 0);
    }

    TipoRetorno tipoRetorno = new TipoRetorno();
    tipoRetorno.setType(typeInteger);

    semanticErrorManager.semanticDebug("TipoRetorno construido: " + tipoRetorno.toString());

    RESULT = tipoRetorno;
:}
| BOOLEAN
{:
    semanticErrorManager.semanticInfo("Procesando tipo de retorno BOOLEAN.");
    
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeBoolean typeBoolean = (TypeBoolean) scopeManager.searchType("BOOLEAN");

    if (typeBoolean == null) {
        semanticFatalError("Tipo BOOLEAN no encontrado en tabla de tipos.", 0, 0);
    }

    TipoRetorno tipoRetorno = new TipoRetorno();
    tipoRetorno.setType(typeBoolean);

    semanticErrorManager.semanticDebug("TipoRetorno construido: " + tipoRetorno.toString());

    RESULT = tipoRetorno;
:};

declaracionesFunction ::= grupoDeclaraciones1:gd1
{:
    semanticErrorManager.semanticInfo("Procesando declaraciones locales de la función.");
    DeclaracionesFunction declaracionesFunction = new DeclaracionesFunction();
    declaracionesFunction.setGrupoDeclaraciones1((GrupoDeclaraciones1) gd1);

    semanticErrorManager.semanticDebug("DeclaracionesFunction generadas: " + declaracionesFunction.toString());

    RESULT = declaracionesFunction;
:};
                    
cuerpoFunction ::= BEGIN sentencias:s END IDENTIFICADOR:id DELIMPUNTOCOMA
{:
    semanticErrorManager.semanticInfo("Procesando cuerpo de función: END " + ((Token)id).getLexema());

    CuerpoFunction cuerpoFunction = new CuerpoFunction();
    cuerpoFunction.setSentencias((Sentencias) s);

    semanticErrorManager.semanticDebug("CuerpoFunction generado: " + cuerpoFunction.toString());

    RESULT = cuerpoFunction;
:};                                

//declaración procedimiento
declProcedimiento ::= PROCEDURE IDENTIFICADOR:id PARENTESISAP declParametros:dp PARENTESISCIERRE IS declaracionesFunction:df cuerpo:c
{:
    semanticErrorManager.semanticInfo("Procesando declaración de procedimiento con parámetros: " + id.getLexema());

    DeclProcedimiento declProcedimiento = new DeclProcedimiento();
    declProcedimiento.setNombre(id.getLexema());
    declProcedimiento.setParametros((DeclParametros) dp);
    declProcedimiento.setDeclaraciones((DeclaracionesFunction) df);
    declProcedimiento.setCuerpo((Cuerpo) c);

    semanticErrorManager.semanticDebug("Procedimiento declarado: " + declProcedimiento.toString());

    RESULT = declProcedimiento;
:}
| PROCEDURE IDENTIFICADOR:id PARENTESISAP PARENTESISCIERRE IS declaracionesFunction:df cuerpo:c
{:
    semanticErrorManager.semanticInfo("Procesando declaración de procedimiento sin parámetros: " + id.getLexema());

    DeclProcedimiento declProcedimiento = new DeclProcedimiento();
    declProcedimiento.setNombre(id.getLexema());
    declProcedimiento.setParametros(null);
    declProcedimiento.setDeclaraciones((DeclaracionesFunction) df);
    declProcedimiento.setCuerpo((Cuerpo) c);

    semanticErrorManager.semanticDebug("Procedimiento declarado: " + declProcedimiento.toString());

    RESULT = declProcedimiento;
:};   

//Cuerpo del procedimiento   
cuerpo ::= BEGIN sentencias:s END IDENTIFICADOR:id DELIMPUNTOCOMA
{:
    semanticErrorManager.semanticInfo("Procesando cuerpo de procedimiento con sentencias: END " + ((Token)id).getLexema());

    Cuerpo cuerpo = new Cuerpo();
    cuerpo.setSentencias((Sentencias) s);

    // Generación de código intermedio
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (s.getIntermediateCode() != null) {
        intermediateCode.addAll(s.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    cuerpo.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Cuerpo generado con sentencias: " + cuerpo.toString());

    RESULT = cuerpo;
:}
| BEGIN END IDENTIFICADOR:id DELIMPUNTOCOMA
{:
    semanticErrorManager.semanticInfo("Procesando cuerpo vacío de procedimiento: END " + ((Token)id).getLexema());

    Cuerpo cuerpo = new Cuerpo();
    cuerpo.setSentencias(null);

    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
    iCb.addQuadruple(Nemonic.RET);

    cuerpo.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Cuerpo generado sin sentencias (vacío): " + cuerpo.toString());

    RESULT = cuerpo;
:};        
                             
//sentencias                        
sentencias ::= sentencia:s sentencias:ss
{:
    semanticErrorManager.semanticInfo("Añadiendo sentencia a la lista de sentencias.");

    Sentencias sentencias = new Sentencias();
    sentencias.addSentencia((Sentencia) s);
    sentencias.getSentencias().addAll(((Sentencias) ss).getSentencias());

    // Código intermedio de la sentencia añadida
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (s.getIntermediateCode() != null) {
        intermediateCode.addAll(s.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    sentencias.setIntermediateCode(intermediateCode);
    // Código intermedio de las sentencias siguientes
    if (((Sentencias) ss).getIntermediateCode() != null) {
        sentencias.getIntermediateCode().addAll(((Sentencias) ss).getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    sentencias.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Sentencia añadida: " + s.toString());
    semanticErrorManager.semanticDebug("Lista de sentencias actualizada: " + sentencias.toString());

    RESULT = sentencias;
:}
| sentencia:s
{:
    semanticErrorManager.semanticInfo("Creando lista de sentencias con una única sentencia.");

    Sentencias sentencias = new Sentencias();
    sentencias.addSentencia((Sentencia) s);

    // Código intermedio de la sentencia única
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (s.getIntermediateCode() != null) {
        intermediateCode.addAll(s.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    sentencias.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Sentencia única: " + s.toString());
    semanticErrorManager.semanticDebug("Lista de sentencias creada: " + sentencias.toString());

    RESULT = sentencias;
:};

sentencia ::= sentenciaPutLine:sp
{:
    semanticErrorManager.semanticInfo("Procesando sentencia Put_line.");

    Sentencia sentencia = new Sentencia();
    sentencia.setSentenciaPutLine((SentenciaPutLine) sp);

    semanticErrorManager.semanticDebug("Sentencia creada: " + sentencia.toString());

    // Generación de código intermedio
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (sp.getIntermediateCode() != null) {
        intermediateCode.addAll(sp.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    sentencia.setIntermediateCode(intermediateCode);

    RESULT = sentencia;
:}
| sentenciaAsignacion:sa
{:
    semanticErrorManager.semanticInfo("Procesando sentencia de asignación.");

    Sentencia sentencia = new Sentencia();
    sentencia.setSentenciaAsignacion((SentenciaAsignacion) sa);

    // Generación de código intermedio
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (sa.getIntermediateCode() != null) {
        intermediateCode.addAll(sa.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    sentencia.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Sentencia creada: " + sentencia.toString());

    RESULT = sentencia;
:}
| sentenciaIf:si
{:
    semanticErrorManager.semanticInfo("Procesando sentencia IF.");

    Sentencia sentencia = new Sentencia();
    sentencia.setSentenciaIf((SentenciaIf) si);
    
    // Generación de código intermedio
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (si.getIntermediateCode() != null) {
        intermediateCode.addAll(si.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    sentencia.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Sentencia creada: " + sentencia.toString());

    RESULT = sentencia;
:}
| sentenciaWhile:sw
{:
    semanticErrorManager.semanticInfo("Procesando sentencia WHILE.");

    Sentencia sentencia = new Sentencia();
    sentencia.setSentenciaWhile((SentenciaWhile) sw);

    // Generación de código intermedio
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (sw.getIntermediateCode() != null) {
        intermediateCode.addAll(sw.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    sentencia.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Sentencia creada: " + sentencia.toString());

    RESULT = sentencia;
:}
| sentenciaReturn:sr
{:
    semanticErrorManager.semanticInfo("Procesando sentencia RETURN.");

    Sentencia sentencia = new Sentencia();
    sentencia.setSentenciaReturn((SentenciaReturn) sr);

    // Generación de código intermedio
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (sr.getIntermediateCode() != null) {
        intermediateCode.addAll(sr.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    sentencia.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Sentencia creada: " + sentencia.toString());

    RESULT = sentencia;
:}
| sentenciaProcedimiento:spc
{:
    semanticErrorManager.semanticInfo("Procesando llamada a procedimiento.");

    Sentencia sentencia = new Sentencia();
    sentencia.setSentenciaProcedimiento((SentenciaProcedimiento) spc);

    // Generación de código intermedio
    List<QuadrupleIF> intermediateCode = new ArrayList<>();
    if (spc.getIntermediateCode() != null) {
        intermediateCode.addAll(spc.getIntermediateCode());
    } else {
        semanticFatalError(SemanticErrors.NPV, 0, 0);
    }
    sentencia.setIntermediateCode(intermediateCode);

    semanticErrorManager.semanticDebug("Sentencia creada: " + sentencia.toString());

    RESULT = sentencia;
:};
       
//sentencia asignación            
sentenciaAsignacion ::= ref:r ASIGNACION:a expresion:e DELIMPUNTOCOMA
{:
    semanticErrorManager.semanticInfo("Procesando sentencia de asignación.");

    Ref referencia = (Ref) r;
    Expresion expresion = (Expresion) e;

    // Validación de tipos
    if (!referencia.getType().equals(expresion.getType())) {
        semanticFatalError("Error de tipos en asignación. Se esperaba tipo " +
            referencia.getType().getName() + ", pero se obtuvo " +
            expresion.getType().getName(), 
            ((Token) a).getLine(), ((Token) a).getColumn());
    }

    // Construcción de la sentencia
    SentenciaAsignacion sentenciaAsignacion = new SentenciaAsignacion();
    sentenciaAsignacion.setRef(referencia);
    sentenciaAsignacion.setExpresion(expresion);

    // Generación de código intermedio
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
    iCb.addQuadruples(expresion.getIntermediateCode());
    iCb.addQuadruple(Nemonic.MOVE, referencia.getVariable(), expresion.getTemporal());

    sentenciaAsignacion.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Código intermedio generado para asignación: " + sentenciaAsignacion.getIntermediateCode());

    RESULT = sentenciaAsignacion;
:};

ref ::= IDENTIFICADOR:id
{:
    String nombre = id.getLexema();
    semanticErrorManager.semanticInfo("Procesando referencia simple a variable: " + nombre);

    ScopeIF scope = scopeManager.getCurrentScope();
    SymbolBase simbolo = (SymbolBase) scopeManager.searchSymbol(nombre);

    if (simbolo == null) {
        semanticFatalError("Variable no declarada: " + nombre, id.getLine(), id.getColumn());
    }

    if (!(simbolo instanceof SymbolVariable)) {
        semanticFatalError("El identificador '" + nombre + "' no es una variable.", id.getLine(), id.getColumn());
    }

    Ref ref = new Ref();
    ref.setType(simbolo.getType());
    ref.setSymbol(simbolo); // Asignamos el símbolo para usarlo en getVariable()

    // Código intermedio: leer valor de variable en un temporal
    TemporalFactory tf = new TemporalFactory(scope);
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
    TemporalIF temporal = tf.create();

    Variable var = new Variable(nombre, simbolo.getScope());
    iCb.addQuadruple(Nemonic.MVP, temporal, var);

    ref.setIntermediateCode(iCb.create());
    ref.setTemporal(temporal);

    semanticErrorManager.semanticDebug("Referencia creada: nombre=" + nombre + ", tipo=" + simbolo.getType().getName());
    semanticErrorManager.semanticDebug("Objeto Ref: " + ref.toString());

    RESULT = ref;
:}
| expresionAccesoRegistro:ear
{:
    semanticErrorManager.semanticInfo("Procesando referencia a campo de registro.");

    ExpresionAccesoRegistro acceso = (ExpresionAccesoRegistro) ear;

    Ref ref = new Ref();
    ref.setType(acceso.getType());
    ref.setTemporal(acceso.getTemporal());
    ref.setIntermediateCode(acceso.getIntermediateCode());

    semanticErrorManager.semanticDebug("Referencia a campo de registro con tipo: " + ref.getType().getName());
    semanticErrorManager.semanticDebug("Objeto Ref: " + ref.toString());

    RESULT = ref;
:};

//sentencia if
sentenciaIf ::= IF expresion:e THEN sentencias:st END IF DELIMPUNTOCOMA
{:
    semanticErrorManager.semanticInfo("Procesando sentencia IF (sin ELSE)");

    ScopeIF scope = scopeManager.getCurrentScope();
    TypeBoolean typeBoolean = (TypeBoolean) scopeManager.searchType("BOOLEAN");

    Expresion condicion = (Expresion)e;
    Sentencias cuerpoThen = (Sentencias)st;

    // Validación de tipo
    if (!condicion.getType().equals(typeBoolean)) {
        semanticFatalError("La condición del IF debe ser de tipo BOOLEAN.", 0, 0);
    }

    SentenciaIf sentenciaIf = new SentenciaIf();
    sentenciaIf.setCondicion(condicion);
    sentenciaIf.setCuerpoThen(cuerpoThen);

    // Generación de código intermedio
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
    LabelFactory lf = new LabelFactory();
    LabelIF etiquetaFinIf = lf.create();

    semanticErrorManager.semanticDebug("Etiqueta FIN_IF: " + etiquetaFinIf.getName());

    iCb.addQuadruples(condicion.getIntermediateCode());
    iCb.addQuadruple(Nemonic.BRF, condicion.getTemporal(), etiquetaFinIf);
    iCb.addQuadruples(cuerpoThen.getIntermediateCode());
    iCb.addQuadruple(Nemonic.INL, etiquetaFinIf);

    sentenciaIf.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Código intermedio generado para IF sin ELSE: " + sentenciaIf.getIntermediateCode());

    RESULT = sentenciaIf;
:}
| IF expresion:e THEN sentencias:st ELSE sentencias:se END IF DELIMPUNTOCOMA
{:
    semanticErrorManager.semanticInfo("Procesando sentencia IF (con ELSE)");

    ScopeIF scope = scopeManager.getCurrentScope();
    TypeBoolean typeBoolean = (TypeBoolean) scopeManager.searchType("BOOLEAN");

    Expresion condicion = (Expresion)e;
    Sentencias cuerpoThen = (Sentencias)st;
    Sentencias cuerpoElse = (Sentencias)se;

    // Validación de tipo
    if (!condicion.getType().equals(typeBoolean)) {
        semanticFatalError("La condición del IF debe ser de tipo BOOLEAN.", 0, 0);
    }

    SentenciaIf sentenciaIf = new SentenciaIf();
    sentenciaIf.setCondicion(condicion);
    sentenciaIf.setCuerpoThen(cuerpoThen);
    sentenciaIf.setCuerpoElse(cuerpoElse);

    // Generación de código intermedio
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
    LabelFactory lf = new LabelFactory();
    LabelIF etiquetaElse = lf.create();
    LabelIF etiquetaFinIf = lf.create();

    semanticErrorManager.semanticDebug("Etiqueta ELSE: " + etiquetaElse.getName());
    semanticErrorManager.semanticDebug("Etiqueta FIN_IF: " + etiquetaFinIf.getName());

    iCb.addQuadruples(condicion.getIntermediateCode());
    iCb.addQuadruple(Nemonic.BRF, condicion.getTemporal(), etiquetaElse);
    iCb.addQuadruples(cuerpoThen.getIntermediateCode());
    iCb.addQuadruple(Nemonic.BR, etiquetaFinIf);
    iCb.addQuadruple(Nemonic.INL, etiquetaElse);
    iCb.addQuadruples(cuerpoElse.getIntermediateCode());
    iCb.addQuadruple(Nemonic.INL, etiquetaFinIf);

    sentenciaIf.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Código intermedio generado para IF con ELSE: " + sentenciaIf.getIntermediateCode());

    RESULT = sentenciaIf;
:};

//sentencia while
sentenciaWhile ::= WHILE expresion:e LOOP sentencias:st END LOOP DELIMPUNTOCOMA
{:
    semanticErrorManager.semanticInfo("Procesando sentencia WHILE");

    ScopeIF scope = scopeManager.getCurrentScope();
    TypeBoolean typeBoolean = (TypeBoolean) scopeManager.searchType("BOOLEAN");
    Expresion condicion = (Expresion)e;

    if (!condicion.getType().equals(typeBoolean)) {
        semanticFatalError("La condición del WHILE debe ser de tipo BOOLEAN.", 0, 0);
    }

    SentenciaWhile sentenciaWhile = new SentenciaWhile();
    sentenciaWhile.setCondicion(condicion);
    sentenciaWhile.setCuerpo((Sentencias)st);

    // Generación de código intermedio
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
    LabelFactory lf = new LabelFactory();
    LabelIF etiquetaInicioWhile = lf.create();
    LabelIF etiquetaFinWhile = lf.create();

    semanticErrorManager.semanticDebug("Etiqueta INICIO_WHILE: " + etiquetaInicioWhile.getName());
    semanticErrorManager.semanticDebug("Etiqueta FIN_WHILE: " + etiquetaFinWhile.getName());

    iCb.addQuadruple(Nemonic.INL, etiquetaInicioWhile);
    iCb.addQuadruples(condicion.getIntermediateCode());
    iCb.addQuadruple(Nemonic.BRF, condicion.getTemporal(), etiquetaFinWhile);
    iCb.addQuadruples(((Sentencias)st).getIntermediateCode());
    iCb.addQuadruple(Nemonic.BR, etiquetaInicioWhile);
    iCb.addQuadruple(Nemonic.INL, etiquetaFinWhile);

    sentenciaWhile.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Código intermedio generado para WHILE: " + sentenciaWhile.getIntermediateCode());

    RESULT = sentenciaWhile;
:};

//sentencia Put_line
sentenciaPutLine ::= PUTLINE PARENTESISAP parametro:p PARENTESISCIERRE DELIMPUNTOCOMA
{:
    semanticErrorManager.semanticInfo("Procesando sentencia PUT_LINE");

    ScopeIF scope = scopeManager.getCurrentScope();
    SentenciaPutLine sentenciaPutLine = new SentenciaPutLine();
    sentenciaPutLine.setParametro((Parametro)p);

    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);

    if (((Parametro)p).esCadena()) {
        String literal = ((Parametro)p).getCadena();
        semanticErrorManager.semanticDebug("Parametro cadena detectado: \"" + literal + "\"");

        iCb.addQuadruple(Nemonic.WRSTR, literal);
    } else {
        Expresion expr = ((Parametro)p).getExpresion();
        semanticErrorManager.semanticDebug("Parametro expresión de tipo: " + expr.getType().getName());

        iCb.addQuadruples(expr.getIntermediateCode());
        iCb.addQuadruple(Nemonic.WRINT, expr.getTemporal());
    }

    sentenciaPutLine.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Código intermedio generado para PUT_LINE: " + sentenciaPutLine.getIntermediateCode());

    RESULT = sentenciaPutLine;
:};

//parametro
parametro ::= expresion:e
{:
    semanticErrorManager.semanticInfo("Procesando parámetro tipo expresión.");

    Parametro parametro = new Parametro((Expresion)e);

    semanticErrorManager.semanticDebug("Expresión de tipo: " + ((Expresion)e).getType().getName());
    semanticErrorManager.semanticDebug("Temporal asociado: " + ((Expresion)e).getTemporal());
    semanticErrorManager.semanticDebug("Objeto Parametro generado: " + parametro.toString());

    RESULT = parametro;
:}
| CADENACARACTERES:cad
{:
    semanticErrorManager.semanticInfo("Procesando parámetro tipo cadena de caracteres.");

    Parametro parametro = new Parametro(cad.getLexema());

    semanticErrorManager.semanticDebug("Texto de la cadena: \"" + cad.getLexema() + "\"");
    semanticErrorManager.semanticDebug("Objeto Parametro generado: " + parametro.toString());

    RESULT = parametro;
:};

//sentencia Return 
sentenciaReturn ::= RETURN expresion:e DELIMPUNTOCOMA
{:
    semanticErrorManager.semanticInfo("Procesando sentencia RETURN");

    ScopeIF scope = scopeManager.getCurrentScope();
    Expresion expr = (Expresion)e;

    SentenciaReturn sentenciaReturn = new SentenciaReturn();
    sentenciaReturn.setExpresion(expr);

    // Validación opcional del tipo de retorno de función
    /*
    TypeIF tipoRetornoFuncion = obtenerTipoDeLaFuncionActual(); // TODO
    if (!expr.getType().equals(tipoRetornoFuncion)) {
         semanticFatalError("Tipo de retorno incorrecto en RETURN.", 0, 0);
    }
    */

    // Generación de código intermedio
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
    iCb.addQuadruples(expr.getIntermediateCode());
    iCb.addQuadruple(Nemonic.RET, expr.getTemporal());

    sentenciaReturn.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Código intermedio RETURN generado con temporal: " + expr.getTemporal());
    semanticErrorManager.semanticDebug("Objeto SentenciaReturn generado: " + sentenciaReturn.toString());

    RESULT = sentenciaReturn;
:};

//sentencia llamada procedimiento
sentenciaProcedimiento ::= IDENTIFICADOR:id PARENTESISAP listaParametrosInvocacion:lpi PARENTESISCIERRE DELIMPUNTOCOMA
{:
    semanticErrorManager.semanticInfo("Procesando llamada a procedimiento con parámetros: " + id.getLexema());

    ScopeIF scope = scopeManager.getCurrentScope();
    SymbolBase simbolo = (SymbolBase) scopeManager.searchSymbol(id.getLexema());

    if (simbolo == null) {
        semanticFatalError("Procedimiento no declarado: " + id.getLexema(), id.getLine(), id.getColumn());
    }
    if (!(simbolo instanceof SymbolProcedure)) {
        semanticFatalError("El identificador '" + id.getLexema() + "' no es un procedimiento.", id.getLine(), id.getColumn());
    }

    SymbolProcedure procedimiento = (SymbolProcedure) simbolo;
    List<SymbolParameter> parametrosFormales = procedimiento.getParameterList();
    List<Expresion> parametrosActuales = ((ListaParametrosInvocacion)lpi).getParametros();

    // Validar número de parámetros
    if (parametrosFormales.size() != parametrosActuales.size()) {
        semanticFatalError("Número incorrecto de parámetros en llamada a procedimiento '" + id.getLexema() + "'.", id.getLine(), id.getColumn());
    }

    // Validar tipo de parámetros
    for (int i = 0; i < parametrosFormales.size(); i++) {
        TypeIF tipoFormal = parametrosFormales.get(i).getType();
        TypeIF tipoActual = parametrosActuales.get(i).getType();

        if (!tipoFormal.equals(tipoActual)) {
            semanticFatalError("Tipo incorrecto en el parámetro " + (i + 1) + " de '" + id.getLexema() + "'. Esperado: " +
                               tipoFormal.getName() + ", recibido: " + tipoActual.getName(), id.getLine(), id.getColumn());
        }

        semanticErrorManager.semanticDebug("Parámetro " + (i + 1) + ": OK. Tipo=" + tipoActual.getName() +
                                            ", Temporal=" + parametrosActuales.get(i).getTemporal());
    }

    // Generación de código intermedio
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);

    for (Expresion parametro : parametrosActuales) {
        iCb.addQuadruples(parametro.getIntermediateCode());
        iCb.addQuadruple(Nemonic.PARAM, parametro.getTemporal());
    }

    iCb.addQuadruple(Nemonic.CALL, procedimiento);

    SentenciaProcedimiento sentenciaProcedimiento = new SentenciaProcedimiento();
    sentenciaProcedimiento.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Llamada a procedimiento con parámetros generada correctamente: " + procedimiento.getName());

    RESULT = sentenciaProcedimiento;
:}
| IDENTIFICADOR:id PARENTESISAP PARENTESISCIERRE DELIMPUNTOCOMA
{:
    semanticErrorManager.semanticInfo("Procesando llamada a procedimiento sin parámetros: " + id.getLexema());

    ScopeIF scope = scopeManager.getCurrentScope();
    SymbolBase simbolo = (SymbolBase) scopeManager.searchSymbol(id.getLexema());

    if (simbolo == null) {
        semanticFatalError("Procedimiento no declarado: " + id.getLexema(), id.getLine(), id.getColumn());
    }
    if (!(simbolo instanceof SymbolProcedure)) {
        semanticFatalError("El identificador '" + id.getLexema() + "' no es un procedimiento.", id.getLine(), id.getColumn());
    }

    SymbolProcedure procedimiento = (SymbolProcedure) simbolo;

    if (!procedimiento.getParameterList().isEmpty()) {
        semanticFatalError("El procedimiento '" + id.getLexema() + "' requiere parámetros.", id.getLine(), id.getColumn());
    }

    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
    iCb.addQuadruple(Nemonic.CALL, procedimiento);

    SentenciaProcedimiento sentenciaProcedimiento = new SentenciaProcedimiento();
    sentenciaProcedimiento.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Llamada a procedimiento sin parámetros generada correctamente: " + procedimiento.getName());

    RESULT = sentenciaProcedimiento;
:};

//expresiones
expresion ::= expresion:e1 operadorLogico:op expresion:e2
{:
    semanticErrorManager.semanticInfo("Procesando expresión lógica.");

    ScopeIF scope = scopeManager.getCurrentScope();
    TypeBoolean typeBoolean = (TypeBoolean) scopeManager.searchType("BOOLEAN");

    if (!e1.getType().equals(typeBoolean) || !e2.getType().equals(typeBoolean)) {
        semanticFatalError("Error de tipos en operación lógica: se esperaban BOOLEAN.", 0, 0);
    }

    Expresion expr = new Expresion();
    TemporalFactory tf = new TemporalFactory(scope);
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);

    TemporalIF t1 = e1.getTemporal();
    TemporalIF t2 = e2.getTemporal();
    TemporalIF t = tf.create();

    iCb.addQuadruples(e1.getIntermediateCode());
    iCb.addQuadruples(e2.getIntermediateCode());
    iCb.addQuadruple(Nemonic.AND, t, t1, t2);  // Se asume operador 'AND'

    expr.setType(typeBoolean);
    expr.setTemporal(t);
    expr.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Expresión lógica generada: temporal=" + t + ", tipo=BOOLEAN");

    RESULT = expr;
:}
| expresion:e1 operadorRelacional:op expresion:e2
{:
    semanticErrorManager.semanticInfo("Procesando expresión relacional.");

    ScopeIF scope = scopeManager.getCurrentScope();
    TypeInteger typeInteger = (TypeInteger) scopeManager.searchType("INTEGER");
    TypeBoolean typeBoolean = (TypeBoolean) scopeManager.searchType("BOOLEAN");

    if (!e1.getType().equals(typeInteger) || !e2.getType().equals(typeInteger)) {
        semanticFatalError("Error de tipos en operación relacional: se esperaban INTEGER.", 0, 0);
    }

    Expresion expr = new Expresion();
    TemporalFactory tf = new TemporalFactory(scope);
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);

    TemporalIF t1 = e1.getTemporal();
    TemporalIF t2 = e2.getTemporal();
    TemporalIF t = tf.create();

    iCb.addQuadruples(e1.getIntermediateCode());
    iCb.addQuadruples(e2.getIntermediateCode());

    switch (op.getOperacion()) {
    case "DISTINTO":
        iCb.addQuadruple(Nemonic.NEQ, t, t1, t2);
        break;
    case "IGUAL":
        iCb.addQuadruple(Nemonic.EQ, t, t1, t2);
        break;
    case "MAYOR":
        iCb.addQuadruple(Nemonic.GR, t, t1, t2);
        break;
    case "MENOR":
        iCb.addQuadruple(Nemonic.LT, t, t1, t2);
        break;
    case "MAYORIGUAL":
        iCb.addQuadruple(Nemonic.GE, t, t1, t2);
        break;
    case "MENORIGUAL":
        iCb.addQuadruple(Nemonic.LE, t, t1, t2);
        break;
    default:
        semanticFatalError("Operador relacional no reconocido: " + op.getOperacion(), 0, 0);
    }

    expr.setType(typeBoolean);
    expr.setTemporal(t);
    expr.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Expresión relacional generada: temporal=" + t + ", tipo=BOOLEAN");

    RESULT = expr;
:}
| expresion:e1 operadorAritmetico:op expresion:e2
{:
    semanticErrorManager.semanticInfo("Procesando expresión aritmética.");

    ScopeIF scope = scopeManager.getCurrentScope();
    TypeInteger typeInteger = (TypeInteger) scopeManager.searchType("INTEGER");

    if (!e1.getType().equals(typeInteger) || !e2.getType().equals(typeInteger)) {
        semanticFatalError("Error de tipos en operación aritmética: se esperaban INTEGER.", 0, 0);
    }

    Expresion expr = new Expresion();
    TemporalFactory tf = new TemporalFactory(scope);
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);

    TemporalIF t1 = e1.getTemporal();
    TemporalIF t2 = e2.getTemporal();
    TemporalIF t = tf.create();

    iCb.addQuadruples(e1.getIntermediateCode());
    iCb.addQuadruples(e2.getIntermediateCode());
    
    switch (op.getOperacion()) {
    case "SUMA":
        iCb.addQuadruple(Nemonic.ADD, t, t1, t2);
        break;
    case "RESTA":
        iCb.addQuadruple(Nemonic.SUB, t, t1, t2);
        break;
    case "MULT":
        iCb.addQuadruple(Nemonic.MUL, t, t1, t2);
        break;
    case "DIVISION":
        iCb.addQuadruple(Nemonic.DIV, t, t1, t2);
        break;
    default:
        semanticFatalError("Operador aritmético no reconocido: " + op.getOperacion(), 0, 0);
    }

    expr.setType(typeInteger);
    expr.setTemporal(t);
    expr.setIntermediateCode(iCb.create());
    semanticErrorManager.semanticDebug("Código intermedio de la expresión: " + iCb.create());

    semanticErrorManager.semanticDebug("Expresión aritmética generada: temporal=" + t + ", tipo=INTEGER");


    RESULT = expr;
:}
| expresionAccesoRegistro:ear
{:
    semanticErrorManager.semanticInfo("Procesando expresión: acceso a campo de registro.");

    Expresion expr = new Expresion();
    expr.setType(((ExpresionAccesoRegistro)ear).getType());
    expr.setTemporal(((ExpresionAccesoRegistro)ear).getTemporal());
    expr.setIntermediateCode(((ExpresionAccesoRegistro)ear).getIntermediateCode());

    semanticErrorManager.semanticDebug("Expresión acceso a registro: tipo=" + expr.getType().getName() + ", temporal=" + expr.getTemporal());

    RESULT = expr;
:}
| exprFuncion:ef
{:
    semanticErrorManager.semanticInfo("Procesando expresión: llamada a función.");

    ScopeIF scope = scopeManager.getCurrentScope();
    TypeTableIF typeTable = scope.getTypeTable();

    Expresion expr = new Expresion();
    TemporalFactory tf = new TemporalFactory(scope);
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);

    TemporalIF temp = tf.create();

    iCb.addQuadruples(((ExprFuncion)ef).getIntermediateCode());
    iCb.addQuadruple(Nemonic.MV, temp, ((ExprFuncion)ef).getTemporal());

    expr.setTemporal(temp);
    expr.setIntermediateCode(iCb.create());
    expr.setType(typeTable.getType("INTEGER")); // Asumido

    semanticErrorManager.semanticDebug("Expresión función generada: temporal=" + temp + ", tipo=INTEGER");

    RESULT = expr;
:}
| operando:o
{:
    semanticErrorManager.semanticInfo("Procesando expresión: operando simple.");

    Expresion expr = new Expresion();
    expr.setType(((Operando)o).getType());
    expr.setTemporal(((Operando)o).getTemporal());
    expr.setIntermediateCode(((Operando)o).getIntermediateCode());

    semanticErrorManager.semanticDebug("Expresión operando: tipo=" + expr.getType().getName() + ", temporal=" + expr.getTemporal());

    RESULT = expr;
:}
| PARENTESISAP expresion:e PARENTESISCIERRE
{:
    semanticErrorManager.semanticInfo("Procesando expresión entre paréntesis.");

    Expresion expr = new Expresion();
    expr.setType(e.getType());
    expr.setTemporal(e.getTemporal());
    expr.setIntermediateCode(e.getIntermediateCode());

    semanticErrorManager.semanticDebug("Expresión paréntesis: tipo=" + expr.getType().getName() + ", temporal=" + expr.getTemporal());

    RESULT = expr;
:};

//operando          
operando ::= BOOLEANO:bool
{:
   semanticErrorManager.semanticInfo("Procesando operando BOOLEANO: " + bool.getLexema());

   ScopeIF scope = scopeManager.getCurrentScope();
   TypeBoolean typeBoolean = (TypeBoolean) scopeManager.searchType("BOOLEAN");

   if (typeBoolean == null) {
       semanticErrorManager.semanticFatalError("[Error] Tipo BOOLEAN no registrado en Scope Global.");
   }

   TemporalFactory tf = new TemporalFactory(scope);
   IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
   TemporalIF temporal = tf.create();

   Value valor = new Value(bool.getLexema().equalsIgnoreCase("True"));
   iCb.addQuadruple(Nemonic.MV, temporal, valor);

   Operando operando = new Operando();
   operando.setTemporal(temporal);
   operando.setType(typeBoolean);
   operando.setIntermediateCode(iCb.create());

   semanticErrorManager.semanticDebug("Operando BOOLEANO generado: temporal=" + temporal + ", valor=" + valor);

   RESULT = operando;
:}
| IDENTIFICADOR:id
{:
   semanticErrorManager.semanticInfo("Procesando operando IDENTIFICADOR: " + id.getLexema());

   ScopeIF scope = scopeManager.getCurrentScope();
   SymbolBase simbolo = (SymbolBase) scopeManager.searchSymbol(id.getLexema());

   if (simbolo == null) {
        semanticErrorManager.semanticDebug("Tabla de símbolos actual: " + scopeManager.getCurrentScope().getSymbolTable());
       semanticErrorManager.semanticFatalError("[Error] Identificador '" + id.getLexema() + "' no declarado.");
   }

   TemporalFactory tf = new TemporalFactory(scope);
   IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
   TemporalIF temporal = tf.create();

   Operando operando = new Operando();
   operando.setTemporal(temporal);
   operando.setType(simbolo.getType());

   if (simbolo instanceof SymbolVariable) {
       Variable var = new Variable(id.getLexema(), simbolo.getScope());
       iCb.addQuadruple(Nemonic.MVP, temporal, var);
       semanticErrorManager.semanticDebug("Identificador es una variable: MVP " + temporal + " <- " + var);
   } else if (simbolo instanceof SymbolConstant) {
       Value valor = new Value(((SymbolConstant) simbolo).getValue());
       iCb.addQuadruple(Nemonic.MV, temporal, valor);
       semanticErrorManager.semanticDebug("Identificador es una constante: MV " + temporal + " <- " + valor);
   } else {
       semanticErrorManager.semanticFatalError("[Error] Identificador '" + id.getLexema() + "' no es ni variable ni constante.");
   }

   operando.setIntermediateCode(iCb.create());

   semanticErrorManager.semanticDebug("Operando IDENTIFICADOR generado: tipo=" + simbolo.getType().getName() + ", temporal=" + temporal);

   RESULT = operando;
:}
| ENTERO:intlit
{:
   semanticErrorManager.semanticInfo("Procesando operando ENTERO: " + intlit.getLexema());

   ScopeIF scope = scopeManager.getCurrentScope();
   TypeInteger typeInteger = (TypeInteger) scopeManager.searchType("INTEGER");

   if (typeInteger == null) {
       semanticErrorManager.semanticFatalError("[Error] Tipo INTEGER no registrado en Scope Global.");
   }

   TemporalFactory tf = new TemporalFactory(scope);
   IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
   TemporalIF temporal = tf.create();

   Value valor = new Value(Integer.parseInt(intlit.getLexema()));
   iCb.addQuadruple(Nemonic.MV, temporal, valor);

   Operando operando = new Operando();
   operando.setTemporal(temporal);
   operando.setType(typeInteger);
   operando.setIntermediateCode(iCb.create());

   semanticErrorManager.semanticDebug("Operando ENTERO generado: valor=" + valor + ", temporal=" + temporal);

   RESULT = operando;
:};

operadorRelacional ::= DISTINTO
{:
    semanticErrorManager.semanticInfo("Procesando operador relacional: DISTINTO");

    OperadorRelacional operador = new OperadorRelacional();
    operador.setOperacion("DISTINTO");

    semanticErrorManager.semanticDebug("OperadorRelacional creado: " + operador.getOperacion());

    RESULT = operador;
:}
| MAYOR
{:
    semanticErrorManager.semanticInfo("Procesando operador relacional: MAYOR");

    OperadorRelacional operador = new OperadorRelacional();
    operador.setOperacion("MAYOR");

    semanticErrorManager.semanticDebug("OperadorRelacional creado: " + operador.getOperacion());

    RESULT = operador;
:};
                        
operadorAritmetico ::= MINUS
{:
    semanticErrorManager.semanticInfo("Procesando operador aritmético: RESTA");

    OperadorAritmetico operador = new OperadorAritmetico();
    operador.setOperacion("RESTA");

    semanticErrorManager.semanticDebug("OperadorAritmetico creado: " + operador.getOperacion());

    RESULT = operador;
:}
| MULT
{:
    semanticErrorManager.semanticInfo("Procesando operador aritmético: MULT");

    OperadorAritmetico operador = new OperadorAritmetico();
    operador.setOperacion("MULT");

    semanticErrorManager.semanticDebug("OperadorAritmetico creado: " + operador.getOperacion());

    RESULT = operador;
:};

operadorLogico ::= AND
{:
    semanticErrorManager.semanticInfo("Procesando operador lógico: AND");

    OperadorLogico operador = new OperadorLogico();
    operador.setOperacion("AND");

    semanticErrorManager.semanticDebug("OperadorLogico creado: " + operador.getOperacion());

    RESULT = operador;
:};

                
                                              
//expresion de acceso a campos de registros                         
expresionAccesoRegistro ::= IDENTIFICADOR:id1 ACCESO IDENTIFICADOR:id2
{:
    semanticErrorManager.semanticInfo("Procesando acceso simple a campo de record: " + id1.getLexema() + "." + id2.getLexema());

    ScopeIF scope = scopeManager.getCurrentScope();
    SymbolBase simbolo = (SymbolBase) scopeManager.searchSymbol(id1.getLexema());

    if (simbolo == null) {
        semanticFatalError("Identificador no declarado: " + id1.getLexema(), id1.getLine(), id1.getColumn());
    }

    if (!(simbolo.getType() instanceof TypeRecord)) {
        semanticFatalError("Acceso no permitido: '" + id1.getLexema() + "' no es un RECORD.", id1.getLine(), id1.getColumn());
    }

    TypeRecord typeRecord = (TypeRecord) simbolo.getType();
    TypeIF tipoCampo = typeRecord.getCampo(id2.getLexema());

    if (tipoCampo == null) {
        semanticFatalError("El campo '" + id2.getLexema() + "' no existe en el RECORD '" + id1.getLexema() + "'.", id2.getLine(), id2.getColumn());
    }

    // Construcción
    ExpresionAccesoRegistro ear = new ExpresionAccesoRegistro();
    ear.setType(tipoCampo);
    ear.setFirstField(id2.getLexema());

    // Código intermedio
    TemporalFactory tf = new TemporalFactory(scope);
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
    TemporalIF temp = tf.create();
    Variable registro = new Variable(id1.getLexema(), simbolo.getScope());
    Field campo = new Field(registro, id2.getLexema());

    iCb.addQuadruple(Nemonic.MVR, temp, campo);

    ear.setTemporal(temp);
    ear.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Acceso a campo '" + id2.getLexema() + "' del record '" + id1.getLexema() +
                                       "' generado correctamente. Temporal: " + temp + ", Tipo: " + tipoCampo.getName());

    RESULT = ear;
:}
| IDENTIFICADOR:id1 ACCESO expresionAccesoRegistro:ear
{:
    semanticErrorManager.semanticInfo("Procesando acceso encadenado: " + id1.getLexema() + ".<subregistro>");

    ScopeIF scope = scopeManager.getCurrentScope();
    SymbolBase simbolo = (SymbolBase) scopeManager.searchSymbol(id1.getLexema());

    if (simbolo == null) {
        semanticFatalError("Identificador no declarado: " + id1.getLexema(), id1.getLine(), id1.getColumn());
    }

    if (!(simbolo.getType() instanceof TypeRecord)) {
        semanticFatalError("Acceso no permitido: '" + id1.getLexema() + "' no es un RECORD.", id1.getLine(), id1.getColumn());
    }

    TypeRecord typeRecord = (TypeRecord) simbolo.getType();
    TypeIF tipoCampo = typeRecord.getCampo(ear.getFirstField());

    if (tipoCampo == null) {
        semanticFatalError("El campo '" + ear.getFirstField() + "' no existe en el record '" + id1.getLexema() + "'.", id1.getLine(), id1.getColumn());
    }

    ExpresionAccesoRegistro nuevoEar = new ExpresionAccesoRegistro();
    nuevoEar.setType(ear.getType());
    nuevoEar.setFirstField(ear.getFirstField());

    // Código intermedio
    TemporalFactory tf = new TemporalFactory(scope);
    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
    TemporalIF temp = tf.create();

    Variable registro = new Variable(id1.getLexema(), simbolo.getScope());
    Field campo = new Field(registro, ear.getFirstField());

    iCb.addQuadruple(Nemonic.MVR, temp, campo);
    iCb.addQuadruples(ear.getIntermediateCode());

    nuevoEar.setTemporal(temp);
    nuevoEar.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Acceso encadenado generado: temporal=" + temp + ", tipo final=" + ear.getType().getName());

    RESULT = nuevoEar;
:};


//invocación de funciones                    
exprFuncion ::= IDENTIFICADOR:id PARENTESISAP listaParametrosInvocacion:lpi PARENTESISCIERRE
{:
    semanticErrorManager.semanticInfo("Procesando invocación de función con parámetros: " + id.getLexema());

    ScopeIF scope = scopeManager.getCurrentScope();
    SymbolBase simbolo = (SymbolBase) scopeManager.searchSymbol(id.getLexema());

    if (simbolo == null) {
        semanticErrorManager.semanticDebug("Tabla de símbolos actual: " + scopeManager.getCurrentScope().getSymbolTable());
        semanticFatalError("Función no declarada: " + id.getLexema(), id.getLine(), id.getColumn());
    }
    if (!(simbolo instanceof SymbolFunction)) {
        semanticFatalError("El identificador '" + id.getLexema() + "' no es una función.", id.getLine(), id.getColumn());
    }

    SymbolFunction function = (SymbolFunction) simbolo;
    List<SymbolParameter> parametrosFormales = function.getParameterList();
    List<Expresion> parametrosActuales = ((ListaParametrosInvocacion)lpi).getParametros();

    if (parametrosFormales.size() != parametrosActuales.size()) {
        semanticFatalError("Número incorrecto de parámetros en llamada a función '" + id.getLexema() + "'.", id.getLine(), id.getColumn());
    }

    for (int i = 0; i < parametrosFormales.size(); i++) {
        TypeIF tipoFormal = parametrosFormales.get(i).getType();
        TypeIF tipoActual = parametrosActuales.get(i).getType();

        if (!tipoFormal.equals(tipoActual)) {
            semanticFatalError("Tipo incorrecto en el parámetro " + (i + 1) + " de la función '" + id.getLexema() + "'.", id.getLine(), id.getColumn());
        }

        semanticErrorManager.semanticDebug("Parámetro " + (i + 1) + ": OK. Tipo=" + tipoActual.getName() +
                                            ", Temporal=" + parametrosActuales.get(i).getTemporal());
    }

    ExprFuncion exprFuncion = new ExprFuncion();
    exprFuncion.setFuncion(function);

    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);

    for (Expresion parametro : parametrosActuales) {
        iCb.addQuadruples(parametro.getIntermediateCode());
        iCb.addQuadruple(Nemonic.PARAM, parametro.getTemporal());
    }

    iCb.addQuadruple(Nemonic.CALL, function);

    // Añadir instrucción para mover el valor de retorno
    TemporalFactory tf = new TemporalFactory(scope);
    TemporalIF tempRet = tf.create();
    iCb.addQuadruple(Nemonic.MV, tempRet, new Retval());

    exprFuncion.setTemporal(tempRet);
    exprFuncion.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Llamada a función generada: retorno -> temporal " + tempRet);

    RESULT = exprFuncion;
:}
| IDENTIFICADOR:id PARENTESISAP PARENTESISCIERRE
{:
    semanticErrorManager.semanticInfo("Procesando invocación de función sin parámetros: " + id.getLexema());

    ScopeIF scope = scopeManager.getCurrentScope();
    SymbolBase simbolo = (SymbolBase) scopeManager.searchSymbol(id.getLexema());

    if (simbolo == null) {
        semanticFatalError("Función no declarada: " + id.getLexema(), id.getLine(), id.getColumn());
    }
    if (!(simbolo instanceof SymbolFunction)) {
        semanticFatalError("El identificador '" + id.getLexema() + "' no es una función.", id.getLine(), id.getColumn());
    }

    SymbolFunction function = (SymbolFunction) simbolo;

    if (!function.getParameterList().isEmpty()) {
        semanticFatalError("La función '" + id.getLexema() + "' requiere parámetros.", id.getLine(), id.getColumn());
    }

    ExprFuncion exprFuncion = new ExprFuncion();
    exprFuncion.setFuncion(function);

    IntermediateCodeBuilder iCb = new IntermediateCodeBuilder(scope);
    iCb.addQuadruple(Nemonic.CALL, function);

    // Movimiento del valor de retorno
    TemporalFactory tf = new TemporalFactory(scope);
    TemporalIF tempRet = tf.create();
    iCb.addQuadruple(Nemonic.MV, tempRet, new Retval());

    exprFuncion.setTemporal(tempRet);
    exprFuncion.setIntermediateCode(iCb.create());

    semanticErrorManager.semanticDebug("Llamada a función generada: retorno -> temporal " + tempRet);

    RESULT = exprFuncion;
:};
       
listaParametrosInvocacion ::= expresion:e
{:
    semanticErrorManager.semanticInfo("Lista de parámetros: primer parámetro");

    ListaParametrosInvocacion listaParametros = new ListaParametrosInvocacion();
    listaParametros.addParametro((Expresion)e);

    semanticErrorManager.semanticDebug("Parámetro 1 añadido. Tipo: " + e.getType().getName() + ", Temporal: " + e.getTemporal());

    RESULT = listaParametros;
:}
| expresion:e DELIMLISTA listaParametrosInvocacion:lpi
{:
    ListaParametrosInvocacion listaParametros = (ListaParametrosInvocacion)lpi;
    listaParametros.addParametro((Expresion)e);

    int posicion = listaParametros.getParametros().size();

    semanticErrorManager.semanticInfo("Lista de parámetros: añadir parámetro en posición " + posicion);
    semanticErrorManager.semanticDebug("Parámetro " + posicion + " añadido. Tipo: " + e.getType().getName() + ", Temporal: " + e.getTemporal());

    RESULT = listaParametros;
:};              